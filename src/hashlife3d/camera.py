"""
This modules helps you take pictures of arbitrary rectangles, temporally
anti-aliased across any number of generations.
"""

from dataclasses import dataclass


@dataclass
class Extent:
    """
    A square region of the infinite plane.
    """
    x: int
    y: int
    side_length: int

def find_required_quadtree(xmin, xmax, ymin, ymax, tmax):
    """
    Find extent of quadtree that will generate an octree containing the
    specified range.

    Returns a tuple of extents (quadtree, octree_base), where octree_base is the
    octree generated by the quadtree intersected with the plane at t=0.
    """
    # A quadtree extent containing the origin.
    origin_quadtree = Extent(0, 0, 4)
    # Keep extending the origin_quadtree 4x, alternating between north-west
    # direction and south-east direction. At each step, tile the quadtree on an
    # infinite plane. If one of the tiles would generate an octree containing
    # the given range, return its extent.
    def containing_tile(origin_quadtree):
        if tmax > origin_quadtree.side_length // 4:
            return None
        quadtree = Extent(
            origin_quadtree.x + (xmin - origin_quadtree.x) // origin_quadtree.side_length * origin_quadtree.side_length,
            origin_quadtree.y + (ymin - origin_quadtree.y) // origin_quadtree.side_length * origin_quadtree.side_length,
            origin_quadtree.side_length
        )
        octree_base = Extent(
            quadtree.x + quadtree.side_length // 4,
            quadtree.y + quadtree.side_length // 4,
            quadtree.side_length // 2
        )
        if octree_base.x > xmin or octree_base.y > ymin:
            return None
        if octree_base.x + octree_base.side_length < xmax or octree_base.y + octree_base.side_length < ymax:
            return None
        return (quadtree, octree_base)
    while True:
        tile = containing_tile(origin_quadtree)
        if tile is not None:
            return tile
        if ((origin_quadtree.x + (origin_quadtree.x + origin_quadtree.side_length)) // 2 > 0):
            # Midpoint is positive; expand north-west
            origin_quadtree.x -= origin_quadtree.side_length
            origin_quadtree.y -= origin_quadtree.side_length
        origin_quadtree.side_length *= 2
